在C++的类中如果只有基本的数据类型，也就不需要写显式的析构函数，即用默认析构函数就够用了，
但是如果类中有个指向其他类的指针，并且在构造时候分配了新的空间，则在析构函数中必须显式释放这块空间，否则会产生内存泄露，
在STL中空间配置时候destory（）函数会判断要释放的迭代器的指向的对象有没有 trivial destructor（STL中有一个 has_trivial_destructor函数，很容易实现检测）放，
如果有trivial destructor则什么都不做，如果没有即需要执行一些操作，则执行真正的destory函数。destory（）有两个版本，
第一个版本接受一个指针，准备将该指针所指之物析构掉，第二个版本接受first和last两个迭代器，准备将[first，last]范围内的所有对象析构掉。
我们不知道这个范围有多大，万一很大，而每个对象的析构函数都无关痛痒，那么一次次调用这些析构函数，对效率是一种伤害，因此这里首先利用value_type()获得迭代器所指对象的类别，再利用_type_traits<T>判断该型别的析构函数是否无关痛痒，
若是(_true_type)，则什么也不做就结束，若否(_false_type),这才以循环的方式巡访整个范围，并在循环中每经历一个对象就调用第一个版本的destory()。
