
一：首先理解左值，右值、纯右值、将亡值，通用引用的概念。
	左值：可以取地址的、有名字的就是左值。（a=b+c,其中可以对a取地址&a，a是一个左值）
	右值：不能取地址，没有名字的就是右值。（a=b+c,其中不可以对b+c取地址，(b+c)是一个右值）
	【c++11以后右值拆分两个概念一个是将亡值，一个是纯右值】
	将亡值：c++11新增的和右值引用相关的表达式，比如右值引用T&&的函数返回值、std::move的返回值、或者转换为T&&的类型转换函数的函数返回值
	纯右值：（即c++98中右值得概念）运算表达式、临时变量产生的值、类型转换函数的返回值、lambda表达式等 
    通用引用：【博弈看到T&&不一定就是右值得引用】T&&”的另外一个含义是：既可以是rvalue reference也可以是lvalue reference。这样的
references在代码中看起来像是rvalue reference（即"T&&"），我把这样的全能称之为Universal Reference。
二：模板类型推导总结：
template<typename T>
void f(ParamType param);
f(expr); // 从expr推导出T和ParamType的
1：ParamType is a Reference or Pointer, but not a Universal Reference
   template<typename T>
   void f(T& param); // param是一个引用
  定义：int x = 27; // x是一个int  
        const int cx = x; // cx是一个const int  
        const int& rx = x; // rx是const int的引用
    f(x); // T是int，param的类型时int&
    f(cx); // T是const int， param的类型是const int&
    f(rx); // T是const int， param的类型时const int&
    
    template<typename T>
    void f(T* param); // param是一个指针
    定义：int x = 27; // 和之前一样
    const int *px = &x; // px是一个指向const int x的指针
    f(&x); // T是int，param的类型是int*
    f(px); // T是const int ，param的类型时const int*
    推导规则：忽略引用类型，推导携带cv属性。
2：ParamType is a Universal Reference
    template<typename T>
    void f(T&& param); // param现在是一个通用的引用
    
定义：int x = 27; // 和之前一样
    const int cx = x; // 和之前一样
    const int& rx = x; // 和之前一样
    f(x); // x是左值，所以T是int&， param的类型也是int&
    f(cx); // cx是左值，所以T是const int&，param的类型也是const int&
    f(rx); // rx是左值，所以T是const int&， param的类型也是const int&
    f(27); // 27是右值，所以T是int， 所以param的类型是int&&
    推导规则：左值均推导为左值得引用类型，cv属性携带。
    
    
3：ParamType is Neither a Pointer nor a Referen
    template<typename T>
    void f(T param); // param现在是pass-by-value
    int x = 27; // 和之前一样
    const int cx = x; // 和之前一样
    const int& rx = x; // 和之前一样
    f(x); // T和param的类型都是int
    f(cx); // T和param的类型也都是int
    f(rx); // T和param的类型还都是int
    推导规则：去引用，去cv限定。
    
    const char* const ptr = "Fun with pointers";// ptr是一个const指针，指向一个const对象
    f(ptr); // 给参数传递的是一个const char * const类型 传递过程中ptr的const特性会被忽略，但是最外层的const限定内容的特性会被推导出来

总结：
三：理解auto类型推导：
除了一个例外，auto类型推导就是模板类型推导。
auto 类型推导通常和模板类型推导类似，但是 auto 类型推导假定花括号初始化代表的类型是 std::initializer_list ，但是模板类型推导却不是这样，auto 在函数返回值或者lambda参数里面执行模板的类型推导，而不是通常意义
的 auto 类型推导。
使用注意：
①我们可以使用valatile，pointer（*），reference（&），rvalue reference（&&） 来修饰auto。
auto k = 5;  
auto* pK = new auto(k);  
auto** ppK = new auto(&k);  
const auto n = 6;  
②用auto声明的变量必须初始化
auto m; // m should be intialized 
③auto不能与其他类型组合连用
auto int p; // 这是旧auto的做法。  
④函数和模板参数不能被声明为auto
void MyFunction(auto parameter){} // no auto as method argument  
template<auto T> // utter nonsense - not allowed  
void Fun(T t){}  
⑤定义在堆上的变量，使用了auto的表达式必须被初始化
int* p = new auto(0); //fine  
int* pp = new auto(); // should be initialized  
auto x = new auto(); // Hmmm ... no intializer  
auto* y = new auto(9); // Fine. Here y is a int*  
auto z = new auto(9); //Fine. Here z is a int* (It is not just an int)
⑥以为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid
int value = 123;  
auto x2 = (auto)value; // no casting using auto  
auto x3 = static_cast<auto>(value); // same as above   
⑦定义在一个auto序列的变量必须始终推导成同一类型
auto x1 = 5, x2 = 5.0, x3='r';  // This is too much....we cannot combine like this  
⑧auto不能自动推导成CV-qualifiers（constant & volatile qualifiers），除非被声明为引用类型
const int i = 99;  
auto j = i;       // j is int, rather than const int  
j = 100           // Fine. As j is not constant  
// Now let us try to have reference  
auto& k = i;      // Now k is const int&  
k = 100;          // Error. k is constant  
// Similarly with volatile qualifer
⑨auto会退化成指向数组的指针，除非被声明为引用
int a[9];  
auto j = a;  
cout<<typeid(j).name()<<endl; // This will print int*  
auto& k = a;  
cout<<typeid(k).name()<<endl; // This will print int [9]
总结：
四：理解decltype类型推导
decltype 几乎总是得到一个变量或表达式的类型而不需要任何修改
对于非变量名的类型为 T 的左值表达式， decltype 总是返回 T&
C++14 支持 decltype(auto) ，它的行为就像 auto ,从初始化操作来推导类型，但是它推
导类型时使用 decltype 的规则。
总结：

五：理解std::move、std::forward

template<typename T> //C++14; still in
decltype(auto) move(T && param) //namespace std
{
using ReturnType = remove_reference_t<T>&&;
return static_cast<ReturnType>(param);
}


case1：
	void f(Widget&& param); //rvalue reference
	Widget&& var1 = Widget(); //rvalue reference
	auto&& var2 = var1; //not rvalue reference
	template<typename T>void f(std::vector<T>&& param) //rvalue referencete



